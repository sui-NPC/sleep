<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>睡眠・PVT習慣アプリ（改良版）</title>

<!-- Chart.js と simple-statistics を CDN で読み込み -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.7/dist/simple-statistics.min.js"></script>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;margin:0;background:#f7fbff;color:#222}
  header{background:#2d7be8;color:#fff;padding:1rem;text-align:center}
  .container{max-width:980px;margin:1rem auto;padding:0 1rem}
  .card{background:#fff;border-radius:12px;padding:1rem;margin:1rem 0;box-shadow:0 2px 8px rgba(0,0,0,0.08)}
  button{background:#2d7be8;color:#fff;border:none;padding:.8rem 1rem;border-radius:8px;cursor:pointer;font-size:1rem}
  button.warn{background:#e74c3c}
  .feedback{margin-top:.6rem;font-weight:600;color:#e67e22}
  #pvt-area{height:160px;border-radius:10px;border:2px solid #2d7be8;display:flex;align-items:center;justify-content:center;font-size:1.6rem;user-select:none;cursor:pointer;background:#eef7ff}
  table#calendar{width:100%;border-collapse:collapse;margin-top:.6rem}
  table#calendar th, table#calendar td{border:1px solid #ddd;padding:.4rem;text-align:center;height:80px;vertical-align:top}
  .small{font-size:.9rem;color:#555}
  .flex{display:flex;gap:.6rem;flex-wrap:wrap}
  input[type="time"], input[type="date"], input[type="number"]{padding:.4rem;border-radius:6px;border:1px solid #ccc}
  .muted{color:#666;font-size:.9rem}
  canvas{max-width:100%}
</style>
</head>
<body>
<header><h1>睡眠・PVT習慣アプリ — 改良版</h1></header>
<div class="container">

  <div class="card">
    <h2>主要グラフ</h2>
    <canvas id="timeChart" height="160"></canvas>
    <div id="corr-area" class="small muted"></div>
  </div>

  <div class="card">
    <h2>睡眠記録</h2>
    <div class="flex">
      <button id="btn-sleep">おやすみ（現在時刻）</button>
      <button id="btn-wake">おはよう（現在時刻）</button>
      <button id="btn-manual">時刻を指定して記録</button>
      <button id="btn-export" style="background:#1abc9c">エクスポート</button>
      <button id="btn-import" style="background:#f39c12">インポート</button>
      <button id="btn-clear" class="warn">全データ削除</button>
    </div>
    <p id="sleep-feedback" class="feedback"></p>

    <!-- 手動入力モーダル（簡易） -->
    <div id="manual-area" style="display:none;margin-top:.8rem;">
      <label>日付: <input type="date" id="manual-date"></label>
      <label>就寝時刻: <input type="time" id="manual-sleep-time"></label>
      <label>起床時刻: <input type="time" id="manual-wake-time"></label>
      <button id="btn-manual-save">保存</button>
      <button id="btn-manual-cancel">キャンセル</button>
      <p class="small muted">「就寝」または「起床」の片方だけでもOK。就寝・起床両方で睡眠時間が自動算出されます。</p>
    </div>
  </div>

  <div class="card">
    <h2>PVT（反応速度）</h2>
    <p class="small muted">1 日 1 回のテスト推奨 — 既定は 15 試行</p>
    <button id="btn-start-pvt">テスト開始</button>
    <div id="pvt-area">準備中...</div>
    <p id="pvt-feedback" class="feedback"></p>
  </div>

  <div class="card">
    <h2>カレンダー編集</h2>
    <button id="toggle-calendar">カレンダーを表示/非表示</button>
    <table id="calendar" style="display:none;"></table>
    <p class="small muted">セルをクリックで編集モーダルを開きます。</p>
  </div>

  <div class="card">
    <h2>データ整合性 & バックアップ</h2>
    <p class="small muted">データは localStorage に保存されます。保存時にバックアップキー（<code>sleepHistory_backup</code> / <code>pvtHistory_backup</code>）を作成します。</p>
    <button id="btn-restore-backup">最後のバックアップから復元</button>
  </div>

  <!-- 編集モーダル（簡易） -->
  <div id="edit-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center;">
    <div style="background:#fff;padding:1rem;border-radius:10px;max-width:360px;margin:auto">
      <h3>データ編集 <span id="edit-date" class="small muted"></span></h3>
      <label>睡眠時間 (h): <input type="number" step="0.1" id="edit-hours"></label><br>
      <label>PVT 平均 (ms): <input type="number" id="edit-pvt-avg"></label><br>
      <div style="margin-top:.6rem">
        <button id="save-edit">保存</button>
        <button id="delete-edit" class="warn">削除</button>
        <button id="close-edit">閉じる</button>
      </div>
    </div>
  </div>

</div>

<script>
// =========================
// データ構造とロード
// =========================
const SKEY = "sleepHistory_v2";
const PKEY = "pvtHistory_v2";
const S_BACK = "sleepHistory_backup_v2";
const P_BACK = "pvtHistory_backup_v2";

let sleepHistory = [];
let pvtHistory = [];
let tempSleepTime = null;

function getDateString(d) { return d.toISOString().split('T')[0]; }
function timeToHM(d){ return d.toTimeString().split(' ')[0].slice(0,5); }

// ページ読み込み時にlocalStorageから復元
try {
  const tmp = localStorage.getItem('tempSleepTime');
  if (tmp) tempSleepTime = new Date(tmp);
} catch(e) { tempSleepTime = null; }

function safeLoad() {
  try {
    sleepHistory = JSON.parse(localStorage.getItem(SKEY) || "[]");
    pvtHistory = JSON.parse(localStorage.getItem(PKEY) || "[]");
  } catch (e) {
    console.warn("localStorage 読み込みエラー。バックアップを試みます。", e);
    const sb = localStorage.getItem(S_BACK);
    const pb = localStorage.getItem(P_BACK);
    if (sb || pb) {
      try {
        if (sb) sleepHistory = JSON.parse(sb);
        if (pb) pvtHistory = JSON.parse(pb);
        alert("破損データをバックアップから復元しました。");
      } catch (ee) {
        console.error("バックアップも破損しています：", ee);
        sleepHistory = []; pvtHistory = [];
      }
    } else {
      sleepHistory = []; pvtHistory = [];
    }
  }
  validateAndCleanData();
}

function validateAndCleanData(){
  // sleepHistory: date present, hours number (0-24) or null, keep latest if duplicate date
  const sleepMap = {};
  for (let r of sleepHistory){
    if (!r || !r.date) continue;
    if (typeof r.hours === 'string') r.hours = parseFloat(r.hours) || null;
    if (r.hours != null && (r.hours < 0 || r.hours > 48)) continue;
    sleepMap[r.date] = {...(sleepMap[r.date]||{}), ...r};
  }
  sleepHistory = Object.keys(sleepMap).sort().map(d => sleepMap[d]);

  // pvtHistory: date present, avg number sane (0-10000)
  const pvtMap = {};
  for (let r of pvtHistory){
    if (!r || !r.date) continue;
    if (typeof r.avg === 'string') r.avg = parseFloat(r.avg) || null;
    if (r.avg != null && (r.avg < 0 || r.avg > 10000)) continue;
    pvtMap[r.date] = {...(pvtMap[r.date]||{}), ...r};
  }
  pvtHistory = Object.keys(pvtMap).sort().map(d => pvtMap[d]);

  localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
  localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
}

function saveWithBackup(){
  try {
    localStorage.setItem(S_BACK, localStorage.getItem(SKEY) || "[]");
    localStorage.setItem(P_BACK, localStorage.getItem(PKEY) || "[]");
    localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
    localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
    console.log("saved (and backed up).");
  } catch (e) {
    console.error("保存エラー:", e);
    alert("保存に失敗しました。ブラウザのストレージ容量や権限を確認してください。");
  }
}

safeLoad();

// =========================
// Chart: 線グラフ（睡眠時間／PVT）と散布図（相関）
// =========================
const timeCtx = document.getElementById('timeChart').getContext('2d');
let timeChart;

function buildTimeChart(){
  const dates = Array.from(new Set([
    ...sleepHistory.map(r=>r.date),
    ...pvtHistory.map(r=>r.date)
  ])).sort((a,b) => new Date(a) - new Date(b));

  const sleepData = dates.map(d => {
    const rec = sleepHistory.find(r=>r.date===d);
    return rec ? rec.hours : null;
  });

  const pvtData = dates.map(d => {
    const rec = pvtHistory.find(r=>r.date===d);
    return rec ? rec.avg : null;
  });

  const pairs = [];
  pvtHistory.forEach(ph => {
    const srec = sleepHistory.find(s => s.date === ph.date);
    if (srec && srec.hours != null && ph.avg != null) {
      pairs.push({x: srec.hours, y: ph.avg});
    }
  });

  if (!timeChart){
    timeChart = new Chart(timeCtx, {
      type: 'line',
      data: {
        labels: dates,
        datasets: [
          { type: 'line', label: '睡眠時間 (h)', data: sleepData, yAxisID:'y1', borderColor: '#2d7be8', spanGaps: true, tension:0.2 },
          { type: 'line', label: '反応時間 (ms)', data: pvtData, yAxisID:'y2', borderColor: '#e64c3c', spanGaps: true, tension:0.2 },
          { type: 'scatter', label: '散布（睡眠 vs PVT）', data: pairs, xAxisID: 'xSleep', yAxisID: 'yPvt', backgroundColor: '#8e44ad', pointRadius:4 }
        ]
      },
      options: {
        interaction: { mode: 'index', intersect: false },
        stacked: false,
        scales: {
          y1: { type: 'linear', position: 'left', min:0, max:12, title:{display:true,text:'睡眠時間 (h)'} },
          y2: { type: 'linear', position: 'right', min:0, max:1000, title:{display:true,text:'反応時間 (ms)'} },
          x: { display: false },
          xSleep: { display: false, type: 'linear', position: 'bottom' },
          yPvt: { display: false, type: 'linear', position: 'right' }
        },
        plugins: { legend: { display: true } }
      },
      plugins: [{
        id: 'regressionLine',
        afterDatasetsDraw(chart){
          const scatterDs = chart.data.datasets.find(ds => ds.type === 'scatter');
          if (!scatterDs || scatterDs.data.length < 2) return;
          const xs = scatterDs.data.map(p => p.x);
          const ys = scatterDs.data.map(p => p.y);
          try {
            const corr = ss.sampleCorrelation(xs, ys);
            const lr = ss.linearRegression(ss.zip(xs, ys));
            const line = ss.linearRegressionLine(lr);
            const xScale = chart.scales.xSleep;
            const yScale = chart.scales.yPvt;
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const xPx1 = xScale.getPixelForValue(minX);
            const xPx2 = xScale.getPixelForValue(maxX);
            const yVal1 = line(minX);
            const yVal2 = line(maxX);
            const yPx1 = yScale.getPixelForValue(yVal1);
            const yPx2 = yScale.getPixelForValue(yVal2);
            const ctx = chart.ctx;
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(46,204,113,0.9)';
            ctx.moveTo(xPx1, yPx1);
            ctx.lineTo(xPx2, yPx2);
            ctx.stroke();
            ctx.restore();
            document.getElementById('corr-area').textContent =
              `相関 (Pearson): ${corr===null? '計算不可' : corr.toFixed(3)}　回帰: y = ${lr.m.toFixed(2)}x + ${lr.b.toFixed(1)} （x=睡眠時間, y=反応時間 ms）`;
          } catch (e) {
            console.error("回帰線描画エラー:", e);
          }
        }
      }]
    });
  } else {
    timeChart.data.labels = dates;
    timeChart.data.datasets[0].data = sleepData;
    timeChart.data.datasets[1].data = pvtData;
    timeChart.data.datasets[2].data = pairs;
    timeChart.update();
  }
}

// =========================
// 記録処理
// =========================
document.getElementById('btn-sleep').addEventListener('click', ()=>{
  tempSleepTime = new Date();
  localStorage.setItem('tempSleepTime', tempSleepTime.toISOString());
  document.getElementById('sleep-feedback').textContent = '就寝記録しました（' + timeToHM(tempSleepTime) + '）';
});

document.getElementById('btn-wake').addEventListener('click', ()=>{
  if (!tempSleepTime){
    try {
      const tmp = localStorage.getItem('tempSleepTime');
      if (tmp) tempSleepTime = new Date(tmp);
    } catch(e) { tempSleepTime = null; }
  }
  if (!tempSleepTime){
    if (!confirm('直前に「おやすみ」が記録されていません。手動入力しますか？（OK=手動入力, キャンセル=現在時刻で記録）')) {
      const now = new Date();
      const today = getDateString(now);
      const assumedHours = 7.0;
      if (confirm(`就寝時刻がありません。\n現在時刻で起床を記録しますか？\n（就寝時刻が不明なため仮に ${assumedHours} 時間の睡眠として保存します。保存しますか？）`)){
        const idx = sleepHistory.findIndex(r=>r.date===today);
        if (idx>=0){
          if (!confirm('今日の睡眠記録は既に存在します。上書きしますか？')) return;
          sleepHistory[idx].hours = assumedHours;
          sleepHistory[idx].createdAt = new Date().toISOString();
        } else {
          sleepHistory.push({date: today, hours: assumedHours, createdAt: new Date().toISOString()});
        }
        saveWithBackup(); buildTimeChart(); document.getElementById('sleep-feedback').textContent='仮の睡眠時間を保存しました';
        localStorage.removeItem('tempSleepTime');
        return;
      } else {
        showManualArea();
        return;
      }
    } else {
      showManualArea();
      return;
    }
  } else {
    const wake = new Date();
    const diffH = (wake - tempSleepTime) / 1000 / 3600;
    const recDate = getDateString(wake);
    const idx = sleepHistory.findIndex(r=>r.date===recDate);
    if (idx>=0){
      if (!confirm(`${recDate} の睡眠記録は既に存在します。上書きしますか？`)) {
        tempSleepTime = null;
        localStorage.removeItem('tempSleepTime');
        return;
      }
      sleepHistory[idx].hours = parseFloat(diffH.toFixed(1));
      sleepHistory[idx].bedtime = timeToHM(tempSleepTime);
      sleepHistory[idx].waketime = timeToHM(wake);
      sleepHistory[idx].createdAt = new Date().toISOString();
    } else {
      sleepHistory.push({date: recDate, hours: parseFloat(diffH.toFixed(1)), bedtime: timeToHM(tempSleepTime), waketime: timeToHM(wake), createdAt: new Date().toISOString()});
    }
    tempSleepTime = null;
    localStorage.removeItem('tempSleepTime');
    saveWithBackup();
    buildTimeChart();
    document.getElementById('sleep-feedback').textContent = `睡眠時間 ${diffH.toFixed(1)} 時間として保存しました。`;
  }
});

function showManualArea(){
  document.getElementById('manual-area').style.display = 'block';
  const today = new Date();
  document.getElementById('manual-date').value = getDateString(today);
}
document.getElementById('btn-manual').addEventListener('click', showManualArea);
document.getElementById('btn-manual-cancel').addEventListener('click', ()=> document.getElementById('manual-area').style.display='none');

document.getElementById('btn-manual-save').addEventListener('click', ()=>{
  const date = document.getElementById('manual-date').value;
  const st = document.getElementById('manual-sleep-time').value;
  const wt = document.getElementById('manual-wake-time').value;
  if (!date) { alert('日付を指定してください'); return; }
  let hours = null;
  if (st && wt){
    const sd = new Date(date + 'T' + st);
    let wd = new Date(date + 'T' + wt);
    if (wd <= sd) wd.setDate(wd.getDate()+1);
    hours = (wd - sd)/1000/3600;
    hours = parseFloat(hours.toFixed(1));
  } else if (st || wt){
    hours = null;
  } else {
    alert('就寝または起床時刻のいずれかを入力してください。');
    return;
  }
  const idx = sleepHistory.findIndex(r=>r.date===date);
  if (idx>=0){
    if (!confirm('その日の睡眠記録は既にあります。上書きしますか？')) return;
    sleepHistory[idx] = {date, hours, bedtime: st||null, waketime: wt||null, createdAt: new Date().toISOString()};
  } else {
    sleepHistory.push({date, hours, bedtime: st||null, waketime: wt||null, createdAt: new Date().toISOString()});
  }
  saveWithBackup(); buildTimeChart(); document.getElementById('manual-area').style.display='none';
  document.getElementById('sleep-feedback').textContent = '手動入力を保存しました';
});

// =========================
// PVT 実装
// =========================
const pvtArea = document.getElementById('pvt-area');
const pvtFeedback = document.getElementById('pvt-feedback');

document.getElementById('btn-start-pvt').addEventListener('click', ()=> startPVT(15));

function startPVT(totalTrials=15){
  pvtFeedback.textContent='';
  let trial = 0;
  let times = [];
  pvtArea.textContent = '準備中... クリックで中止';
  let running = true;
  pvtArea.onclick = ()=> { running=false; pvtArea.textContent='中止'; pvtFeedback.textContent='テストが中止されました'; };

  function runTrial(){
    if (!running) return;
    if (trial >= totalTrials){
      const avg = times.reduce((a,b)=>a+b,0)/times.length;
      const lapses = times.filter(t=>t>500).length;
      const today = getDateString(new Date());
      const idx = pvtHistory.findIndex(r=>r.date===today);
      if (idx>=0){
        if (!confirm('本日すでに PVT 記録があります。上書きしますか？')) {
          pvtFeedback.textContent = '保存をキャンセルしました';
          return;
        }
        pvtHistory[idx] = {date: today, avg: parseFloat(avg.toFixed(1)), lapses, reactions: times, createdAt: new Date().toISOString()};
      } else {
        pvtHistory.push({date: today, avg: parseFloat(avg.toFixed(1)), lapses, reactions: times, createdAt: new Date().toISOString()});
      }
      saveWithBackup(); buildTimeChart();
      pvtArea.textContent = '完了';
      pvtFeedback.textContent = `平均: ${avg.toFixed(1)}ms, ラプス: ${lapses}回`;
      return;
    }
    pvtArea.textContent = '待機中...';
    const delay = Math.random()*3000 + 1500;
    setTimeout(()=>{
      if (!running) return;
      pvtArea.textContent = 'クリック！';
      const start = performance.now();
      const handler = ()=>{
        const rt = performance.now() - start;
        times.push(rt);
        trial++;
        pvtFeedback.textContent = `試行 ${trial} = ${rt.toFixed(0)} ms`;
        pvtArea.removeEventListener('click', handler);
        runTrial();
      };
      pvtArea.addEventListener('click', handler);
    }, delay);
  }
  runTrial();
}

// =========================
// カレンダー描画＋編集
// =========================
function toggleCalendar(){
  const cal = document.getElementById('calendar');
  cal.style.display = cal.style.display === 'table' ? 'none' : 'table';
  if (cal.style.display === 'table') renderCalendar();
}
document.getElementById('toggle-calendar').addEventListener('click', toggleCalendar);

function renderCalendar(){
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const firstDay = new Date(year, month, 1).getDay();
  const lastDate = new Date(year, month+1, 0).getDate();
  let html = '<tr><th>日</th><th>月</th><th>火</th><th>水</th><th>木</th><th>金</th><th>土</th></tr><tr>';
  for (let i=0;i<firstDay;i++) html += '<td></td>';
  for (let d=1; d<=lastDate; d++){
    const mm = String(month+1).padStart(2,'0');
    const dd = String(d).padStart(2,'0');
    const dateStr = `${year}-${mm}-${dd}`;
    const s = sleepHistory.find(r=>r.date===dateStr);
    const p = pvtHistory.find(r=>r.date===dateStr);
    html += `<td data-date="${dateStr}"><strong>${d}</strong><div class="small">${s ? s.hours + 'h' : ''}</div><div class="small">${p ? p.avg + 'ms' : ''}</div></td>`;
    if ((d+firstDay)%7===0) html += '</tr><tr>';
  }
  html += '</tr>';
  document.getElementById('calendar').innerHTML = html;
  document.querySelectorAll('#calendar td[data-date]').forEach(td=>{
    td.onclick = ()=> {
      const date = td.dataset.date;
      openEditModal(date);
    };
  });
}

let editDate = null;
function openEditModal(date){
  editDate = date;
  document.getElementById('edit-date').textContent = date;
  const s = sleepHistory.find(r=>r.date===date);
  const p = pvtHistory.find(r=>r.date===date);
  document.getElementById('edit-hours').value = s ? (s.hours != null ? s.hours : '') : '';
  document.getElementById('edit-pvt-avg').value = p ? (p.avg != null ? p.avg : '') : '';
  document.getElementById('edit-modal').style.display = 'flex';
}
document.getElementById('close-edit').addEventListener('click', ()=> document.getElementById('edit-modal').style.display='none');

document.getElementById('save-edit').addEventListener('click', ()=>{
  if (!editDate) return;
  const h = parseFloat(document.getElementById('edit-hours').value);
  const a = parseFloat(document.getElementById('edit-pvt-avg').value);
  const sIdx = sleepHistory.findIndex(r=>r.date===editDate);
  if (!isNaN(h)){
    if (sIdx>=0) sleepHistory[sIdx].hours = h;
    else sleepHistory.push({date: editDate, hours: h, createdAt: new Date().toISOString()});
  }
  const pIdx = pvtHistory.findIndex(r=>r.date===editDate);
  if (!isNaN(a)){
    if (pIdx>=0) pvtHistory[pIdx].avg = a;
    else pvtHistory.push({date: editDate, avg: a, lapses: 0, reactions: [], createdAt: new Date().toISOString()});
  }
  saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
  document.getElementById('edit-modal').style.display = 'none';
});
document.getElementById('delete-edit').addEventListener('click', ()=>{
  if (!editDate) return;
  if (!confirm(editDate + ' のデータを削除しますか？')) return;
  sleepHistory = sleepHistory.filter(r=>r.date!==editDate);
  pvtHistory = pvtHistory.filter(r=>r.date!==editDate);
  saveWithBackup(); buildTimeChart(); renderCalendar();
  document.getElementById('edit-modal').style.display = 'none';
});

// =========================
// エクスポート / インポート
// =========================
document.getElementById('btn-export').addEventListener('click', ()=>{
  const data = {sleepHistory, pvtHistory, exportedAt: new Date().toISOString()};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'sleep_pvt_data.json'; a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('btn-import').addEventListener('click', ()=>{
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,application/json';
  input.onchange = (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      try {
        const obj = JSON.parse(ev.target.result);
        if (confirm('インポートしたデータで上書きしますか？（キャンセルでマージ）')){
          sleepHistory = obj.sleepHistory || [];
          pvtHistory = obj.pvtHistory || [];
        } else {
          const mapS = {};
          sleepHistory.forEach(r=> mapS[r.date]=r);
          (obj.sleepHistory||[]).forEach(r=> mapS[r.date]=r);
          sleepHistory = Object.keys(mapS).map(d=>mapS[d]);
          const mapP = {};
          pvtHistory.forEach(r=> mapP[r.date]=r);
          (obj.pvtHistory||[]).forEach(r=> mapP[r.date]=r);
          pvtHistory = Object.keys(mapP).map(d=>mapP[d]);
        }
        saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
        alert('インポート完了');
      } catch (err) {
        alert('ファイルの読み込みに失敗しました:' + err);
      }
    };
    reader.readAsText(f);
  };
  input.click();
});

document.getElementById('btn-clear').addEventListener('click', ()=>{
  if (!confirm('本当に全データを削除しますか？')) return;
  sleepHistory = []; pvtHistory = [];
  saveWithBackup(); buildTimeChart(); renderCalendar();
  alert('すべてのデータを削除しました');
});
document.getElementById('btn-restore-backup').addEventListener('click', ()=>{
  if (!confirm('最後のバックアップから復元しますか？現在のデータは上書きされます。')) return;
  try {
    const sb = JSON.parse(localStorage.getItem(S_BACK) || "[]");
    const pb = JSON.parse(localStorage.getItem(P_BACK) || "[]");
    sleepHistory = sb; pvtHistory = pb;
    saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
    alert('バックアップから復元しました');
  } catch (e) { alert('復元に失敗しました: ' + e); }
});

// =========================
// 起動時処理
// =========================
buildTimeChart();
renderCalendar();

console.log("注意: localStorage は XSS による盗難のリスクがあるため、機密情報は保存しないでください。大規模データや同期が必要なら IndexedDB / サーバー同期を検討してください。");
</script>
</body>
</html>
