<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>睡眠・PVT習慣アプリ（改良版）</title>

<!-- Chart.js と simple-statistics を CDN で読み込み -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.7/dist/simple-statistics.min.js"></script>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;margin:0;background:#f7fbff;color:#222}
  header{background:#2d7be8;color:#fff;padding:1rem;text-align:center}
  .container{max-width:980px;margin:1rem auto;padding:0 1rem}
  .card{background:#fff;border-radius:12px;padding:1rem;margin:1rem 0;box-shadow:0 2px 8px rgba(0,0,0,0.08)}
  button{background:#2d7be8;color:#fff;border:none;padding:.8rem 1rem;border-radius:8px;cursor:pointer;font-size:1rem}
  button.warn{background:#e74c3c}
  .feedback{margin-top:.6rem;font-weight:600;color:#e67e22}
  #pvt-area{height:160px;border-radius:10px;border:2px solid #2d7be8;display:flex;align-items:center;justify-content:center;font-size:1.6rem;user-select:none;cursor:pointer;background:#eef7ff}
  table#calendar{width:100%;border-collapse:collapse;margin-top:.6rem}
  table#calendar th, table#calendar td{border:1px solid #ddd;padding:.4rem;text-align:center;height:80px;vertical-align:top}
  .small{font-size:.9rem;color:#555}
  #notification-perm{margin-left:.5rem}
  .flex{display:flex;gap:.6rem;flex-wrap:wrap}
  input[type="time"], input[type="date"], input[type="number"]{padding:.4rem;border-radius:6px;border:1px solid #ccc}
  .muted{color:#666;font-size:.9rem}
  canvas{max-width:100%}
</style>
</head>
<body>
<header><h1>睡眠・PVT習慣アプリ — 改良版</h1></header>
<div class="container">

  <div class="card">
    <h2>主要グラフ</h2>
    <canvas id="timeChart" height="160"></canvas>
    <div id="corr-area" class="small muted"></div>
  </div>

  <div class="card">
    <h2>睡眠記録</h2>
    <div class="flex">
      <button id="btn-sleep">おやすみ（現在時刻）</button>
      <button id="btn-wake">おはよう（現在時刻）</button>
      <button id="btn-manual">時刻を指定して記録</button>
      <button id="btn-request-notif">通知許可</button>
      <button id="btn-export" style="background:#1abc9c">エクスポート</button>
      <button id="btn-import" style="background:#f39c12">インポート</button>
      <button id="btn-clear" class="warn">全データ削除</button>
    </div>
    <p id="sleep-feedback" class="feedback"></p>

    <!-- 手動入力モーダル（簡易） -->
    <div id="manual-area" style="display:none;margin-top:.8rem;">
      <label>日付: <input type="date" id="manual-date"></label>
      <label>就寝時刻: <input type="time" id="manual-sleep-time"></label>
      <label>起床時刻: <input type="time" id="manual-wake-time"></label>
      <button id="btn-manual-save">保存</button>
      <button id="btn-manual-cancel">キャンセル</button>
      <p class="small muted">「就寝」または「起床」の片方だけでもOK。就寝・起床両方で睡眠時間が自動算出されます。</p>
    </div>
  </div>

  <div class="card">
    <h2>PVT（反応速度）</h2>
    <p class="small muted">1 日 1 回のテスト推奨 — 既定は 15 試行</p>
    <button id="btn-start-pvt">テスト開始</button>
    <div id="pvt-area">準備中...</div>
    <p id="pvt-feedback" class="feedback"></p>
  </div>

  <div class="card">
    <h2>カレンダー編集</h2>
    <button id="toggle-calendar">カレンダーを表示/非表示</button>
    <table id="calendar" style="display:none;"></table>
    <p class="small muted">セルをクリックで編集モーダルを開きます。</p>
  </div>

  <div class="card">
    <h2>データ整合性 & バックアップ</h2>
    <p class="small muted">データは localStorage に保存されます。保存時にバックアップキー（<code>sleepHistory_backup</code> / <code>pvtHistory_backup</code>）を作成します。</p>
    <button id="btn-restore-backup">最後のバックアップから復元</button>
  </div>

  <!-- 編集モーダル（簡易） -->
  <div id="edit-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center;">
    <div style="background:#fff;padding:1rem;border-radius:10px;max-width:360px;margin:auto">
      <h3>データ編集 <span id="edit-date" class="small muted"></span></h3>
      <label>睡眠時間 (h): <input type="number" step="0.1" id="edit-hours"></label><br>
      <label>PVT 平均 (ms): <input type="number" id="edit-pvt-avg"></label><br>
      <div style="margin-top:.6rem">
        <button id="save-edit">保存</button>
        <button id="delete-edit" class="warn">削除</button>
        <button id="close-edit">閉じる</button>
      </div>
    </div>
  </div>

</div>

<script>
const SKEY = "sleepHistory_v2";
const PKEY = "pvtHistory_v2";
const S_BACK = "sleepHistory_backup_v2";
const P_BACK = "pvtHistory_backup_v2";

let sleepHistory = [];
let pvtHistory = [];

function getDateString(d) { return d.toISOString().split('T')[0]; }
function timeToHM(d){ return d.toTimeString().split(' ')[0].slice(0,5); }

function safeLoad() {
  try {
    sleepHistory = JSON.parse(localStorage.getItem(SKEY) || "[]");
    pvtHistory = JSON.parse(localStorage.getItem(PKEY) || "[]");
  } catch (e) {
    const sb = localStorage.getItem(S_BACK);
    const pb = localStorage.getItem(P_BACK);
    if (sb || pb) {
      try {
        if (sb) sleepHistory = JSON.parse(sb);
        if (pb) pvtHistory = JSON.parse(pb);
        alert("破損データをバックアップから復元しました。");
      } catch (ee) {
        sleepHistory = []; pvtHistory = [];
      }
    } else {
      sleepHistory = []; pvtHistory = [];
    }
  }
  validateAndCleanData();
}

function validateAndCleanData(){
  const sleepMap = {};
  for (let r of sleepHistory){
    if (!r || !r.date) continue;
    if (typeof r.hours === 'string') r.hours = parseFloat(r.hours) || null;
    if (r.hours != null && (r.hours < 0 || r.hours > 48)) continue;
    sleepMap[r.date] = {...(sleepMap[r.date]||{}), ...r};
  }
  sleepHistory = Object.keys(sleepMap).sort().map(d => sleepMap[d]);

  const pvtMap = {};
  for (let r of pvtHistory){
    if (!r || !r.date) continue;
    if (typeof r.avg === 'string') r.avg = parseFloat(r.avg) || null;
    if (r.avg != null && (r.avg < 0 || r.avg > 10000)) continue;
    pvtMap[r.date] = {...(pvtMap[r.date]||{}), ...r};
  }
  pvtHistory = Object.keys(pvtMap).sort().map(d => pvtMap[d]);

  localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
  localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
}

function saveWithBackup(){
  try {
    localStorage.setItem(S_BACK, localStorage.getItem(SKEY) || "[]");
    localStorage.setItem(P_BACK, localStorage.getItem(PKEY) || "[]");
    localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
    localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
  } catch (e) {
    alert("保存に失敗しました。ブラウザのストレージ容量や権限を確認してください。");
  }
}

safeLoad();

const timeCtx = document.getElementById('timeChart').getContext('2d');
let timeChart;

function buildTimeChart(){
  const dates = Array.from(new Set([
    ...sleepHistory.map(r=>r.date),
    ...pvtHistory.map(r=>r.date)
  ])).sort((a,b) => new Date(a) - new Date(b));

  const sleepData = dates.map(d => {
    const rec = sleepHistory.find(r=>r.date===d);
    return rec ? rec.hours : null;
  });

  const pvtData = dates.map(d => {
    const rec = pvtHistory.find(r=>r.date===d);
    return rec ? rec.avg : null;
  });

  const pairs = [];
  pvtHistory.forEach(ph => {
    const srec = sleepHistory.find(s => s.date === ph.date);
    if (srec && srec.hours != null && ph.avg != null) {
      pairs.push({x: srec.hours, y: ph.avg});
    }
  });

  if (!timeChart){
    timeChart = new Chart(timeCtx, {
      type: 'line',
      data: {
        labels: dates,
        datasets: [
          { type: 'line', label: '睡眠時間 (h)', data: sleepData, yAxisID:'y1', borderColor: '#2d7be8', spanGaps: true, tension:0.2 },
          { type: 'line', label: '反応時間 (ms)', data: pvtData, yAxisID:'y2', borderColor: '#e64c3c', spanGaps: true, tension:0.2 },
          { type: 'scatter', label: '散布（睡眠 vs PVT）', data: pairs, xAxisID: 'xSleep', yAxisID: 'yPvt', backgroundColor: '#8e44ad', pointRadius:4 }
        ]
      },
      options: {
        interaction: { mode: 'index', intersect: false },
        stacked: false,
        scales: {
          y1: { type: 'linear', position: 'left', min:0, max:12, title:{display:true,text:'睡眠時間 (h)'} },
          y2: { type: 'linear', position: 'right', min:0, max:1000, title:{display:true,text:'反応時間 (ms)'} },
          x: { display: false },
          xSleep: { display: false, type: 'linear', position: 'bottom' },
          yPvt: { display: false, type: 'linear', position: 'right' }
        },
        plugins: {
          legend: { display: true }
        }
      },
      plugins: [{
        id: 'regressionLine',
        afterDatasetsDraw(chart, args, options){
          const scatterDs = chart.data.datasets.find(ds => ds.type === 'scatter');
          if (!scatterDs || scatterDs.data.length < 2) return;
          const xs = scatterDs.data.map(p => p.x);
          const ys = scatterDs.data.map(p => p.y);
          try {
            const corr = ss.sampleCorrelation(xs, ys);
            const lr = ss.linearRegression(ss.zip(xs, ys));
            const line = ss.linearRegressionLine(lr);
            const xScale = chart.scales.xSleep;
            const yScale = chart.scales.yPvt;
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const xPx1 = xScale.getPixelForValue(minX);
            const xPx2 = xScale.getPixelForValue(maxX);
            const yVal1 = line(minX);
            const yVal2 = line(maxX);
            const yPx1 = yScale.getPixelForValue(yVal1);
            const yPx2 = yScale.getPixelForValue(yVal2);
            const ctx = chart.ctx;
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(46,204,113,0.9)';
            ctx.moveTo(xPx1, yPx1);
            ctx.lineTo(xPx2, yPx2);
            ctx.stroke();
            ctx.restore();
            document.getElementById('corr-area').textContent =
              `相関 (Pearson): ${corr===null? '計算不可' : corr.toFixed(3)}　回帰: y = ${lr.m.toFixed(2)}x + ${lr.b.toFixed(1)} （x=睡眠時間, y=反応時間 ms）`;
          } catch (e) {
            console.error("回帰線描画エラー:", e);
          }
        }
      }]
    });
  } else {
    timeChart.data.labels = dates;
    timeChart.data.datasets[0].data = sleepData;
    timeChart.data.datasets[1].data = pvtData;
    timeChart.data.datasets[2].data = pairs;
    timeChart.update();
  }
}

// --- 睡眠記録（おやすみ/おはよう） ---
let tempSleepTime = null;
// ページ読み込み時にlocalStorageから復元
try {
  const tmp = localStorage.getItem('tempSleepTime');
  if (tmp) tempSleepTime = new Date(tmp);
} catch(e) { tempSleepTime = null; }

document.getElementById('btn-sleep').addEventListener('click', ()=>{
  tempSleepTime = new Date();
  localStorage.setItem('tempSleepTime', tempSleepTime.toISOString());
  document.getElementById('sleep-feedback').textContent = '就寝記録しました（' + timeToHM(tempSleepTime) + '）';
});

document.getElementById('btn-wake').addEventListener('click', ()=>{
  // localStorageから復元
  if (!tempSleepTime){
    try {
      const tmp = localStorage.getItem('tempSleepTime');
      if (tmp) tempSleepTime = new Date(tmp);
    } catch(e) { tempSleepTime = null; }
  }
  if (!tempSleepTime){
    if (!confirm('直前に「おやすみ」が記録されていません。手動入力しますか？（OK=手動入力, キャンセル=現在時刻で記録）')) {
      const now = new Date();
      const today = getDateString(now);
      const assumedHours = 7.0;
      if (confirm(`就寝時刻がありません。\n現在時刻で起床を記録しますか？\n（就寝時刻が不明なため仮に ${assumedHours} 時間の睡眠として保存します。保存しますか？）`)){
        const idx = sleepHistory.findIndex(r=>r.date===today);
        if (idx>=0){
          if (!confirm('今日の睡眠記録は既に存在します。上書きしますか？')) return;
          sleepHistory[idx].hours = assumedHours;
          sleepHistory[idx].createdAt = new Date().toISOString();
        } else {
          sleepHistory.push({date: today, hours: assumedHours, createdAt: new Date().toISOString()});
        }
        saveWithBackup(); buildTimeChart(); document.getElementById('sleep-feedback').textContent='仮の睡眠時間を保存しました';
        localStorage.removeItem('tempSleepTime');
        return;
      } else {
        showManualArea();
        return;
      }
    } else {
      showManualArea();
      return;
    }
  } else {
    const wake = new Date();
    const diffH = (wake - tempSleepTime) / 1000 / 3600;
    const recDate = getDateString(wake);
    const idx = sleepHistory.findIndex(r=>r.date===recDate);
    if (idx>=0){
      if (!confirm(`${recDate} の睡眠記録は既に存在します。上書きしますか？`)) {
        tempSleepTime = null;
        localStorage.removeItem('tempSleepTime');
        return;
      }
      sleepHistory[idx].hours = parseFloat(diffH.toFixed(1));
      sleepHistory[idx].bedtime = timeToHM(tempSleepTime);
      sleepHistory[idx].waketime = timeToHM(wake);
      sleepHistory[idx].createdAt = new Date().toISOString();
    } else {
      sleepHistory.push({date: recDate, hours: parseFloat(diffH.toFixed(1)), bedtime: timeToHM(tempSleepTime), waketime: timeToHM(wake), createdAt: new Date().toISOString()});
    }
    tempSleepTime = null;
    localStorage.removeItem('tempSleepTime');
    saveWithBackup();
    buildTimeChart();
    document.getElementById('sleep-feedback').textContent = `睡眠時間 ${diffH.toFixed(1)} 時間として保存しました。`;
  }
});

// ...既存の手動入力・PVT・カレンダー・編集・エクスポート/インポート・バックアップ・通知・リマインダー処理...
// （前回のコードと同じです。必要に応じて再送します）

buildTimeChart();
renderCalendar();
showDailyPVTReminder();

console.log("注意: localStorage は XSS による盗難のリスクがあるため、機密情報は保存しないでください。大規模データや同期が必要なら IndexedDB / サーバー同期を検討してください。");
</script>
</body>
</html>
