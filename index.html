<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>睡眠・PVT習慣アプリ</title>

<!-- Chart.js と simple-statistics を CDN で読み込み -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.7/dist/simple-statistics.min.js"></script>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;margin:0;background:#f7fbff;color:#222}
  header{background:#2d7be8;color:#fff;padding:1rem;text-align:center}
  .container{max-width:980px;margin:1rem auto;padding:0 1rem}
  .card{background:#fff;border-radius:12px;padding:1rem;margin:1rem 0;box-shadow:0 2px 8px rgba(0,0,0,0.08)}
  button{background:#2d7be8;color:#fff;border:none;padding:.8rem 1rem;border-radius:8px;cursor:pointer;font-size:1rem}
  button.warn{background:#e74c3c}
  .feedback{margin-top:.6rem;font-weight:600;color:#e67e22}
  #pvt-area{height:160px;border-radius:10px;border:2px solid #2d7be8;display:flex;align-items:center;justify-content:center;font-size:1.6rem;user-select:none;cursor:pointer;background:#eef7ff}
  table#calendar{width:100%;border-collapse:collapse;margin-top:.6rem}
  table#calendar th, table#calendar td{border:1px solid #ddd;padding:.4rem;text-align:center;height:80px;vertical-align:top}
  .small{font-size:.9rem;color:#555}
  #notification-perm{margin-left:.5rem}
  .flex{display:flex;gap:.6rem;flex-wrap:wrap}
  input[type="time"], input[type="date"], input[type="number"]{padding:.4rem;border-radius:6px;border:1px solid #ccc}
  .muted{color:#666;font-size:.9rem}
  canvas{max-width:100%}
  /* detail modal */
  #detail-modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center}
  #detail-modal .dialog{background:#fff;padding:1rem;border-radius:10px;max-width:520px;width:92%;max-height:80vh;overflow:auto}
  #detail-modal h3{margin-top:0}
  .note-star{color:#e67e22;font-weight:700;margin-left:6px}
</style>
</head>
<body>
<header><h1>睡眠・PVT習慣アプリ</h1></header>

<!-- 眠気評価モーダル -->
<div id="sleepiness-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center;z-index:1000;">
  <div style="background:#fff;padding:1.2rem;border-radius:10px;max-width:320px;margin:auto;text-align:center">
    <h3>本日の眠気を評価</h3>
    <p class="small muted">1: 全く眠くない ～ 5: 非常に眠い</p>
    <div id="sleepiness-options" style="margin:1rem 0;"></div>
    <button id="sleepiness-save">保存</button>
    <button id="sleepiness-cancel" style="margin-left:1rem">キャンセル</button>
    <p id="sleepiness-feedback" class="feedback"></p>
  </div>
</div>
<div class="container">

  <div class="card">
    <h2>主要グラフ</h2>
    <canvas id="timeChart" height="160"></canvas>
    <div id="corr-area" class="small muted"></div>
  </div>

  <div class="card">
    <h2>睡眠記録</h2>
    <div class="flex">
      <button id="btn-sleep">おやすみ（現在時刻）</button>
      <button id="btn-wake">おはよう（現在時刻）</button>
      <button id="btn-manual">時刻を指定して記録</button>
      <button id="btn-export" style="background:#1abc9c">エクスポート</button>
      <button id="btn-import" style="background:#f39c12">インポート</button>
      <button id="btn-clear" class="warn">全データ削除</button>
    </div>
    <p id="sleep-feedback" class="feedback"></p>

    <!-- 手動入力モーダル（簡易） -->
    <div id="manual-area" style="display:none;margin-top:.8rem;">
      <label>日付: <input type="date" id="manual-date"></label>
      <label>就寝時刻: <input type="time" id="manual-sleep-time"></label>
      <label>起床時刻: <input type="time" id="manual-wake-time"></label>
      <button id="btn-manual-save">保存</button>
      <button id="btn-manual-cancel">キャンセル</button>
      <p class="small muted">「就寝」または「起床」の片方だけでもOK。就寝・起床両方で睡眠時間が自動算出されます。</p>
    </div>
  </div>

  <div class="card">
    <h2>PVT（反応速度）テスト</h2>
    <p class="small muted">1 日 1 回のテスト</p>
    <p><font color="red">※最初の一週間は使用しないでください！！</font></p>
    <div class="flex">
      <button id="btn-start-pvt">テスト開始</button>
      <button id="btn-cancel-pvt" class="warn" disabled>中止</button>
    </div>
    <div id="pvt-area">準備中...</div>
    <p id="pvt-feedback" class="feedback"></p>
  </div>

  <div class="card">
    <h2>カレンダー編集</h2>
    <button id="toggle-calendar">カレンダーを表示/非表示</button>
    <table id="calendar" style="display:none;"></table>
    <p class="small muted">セルをクリックでその日の詳細を表示します（平均値表示・複数件は (*)）。</p>
  </div>

  <div class="card">
    <h2>データ整合性 & バックアップ</h2>
    <p class="small muted">データは localStorage に保存されます。保存時にバックアップキー（<code>sleepHistory_backup_v2</code> / <code>pvtHistory_backup_v2</code>）を作成します。</p>
    <button id="btn-restore-backup">最後のバックアップから復元</button>
  </div>

  <!-- 編集モーダル（既存の編集用） -->
  <div id="edit-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center;">
    <div style="background:#fff;padding:1rem;border-radius:10px;max-width:360px;margin:auto">
      <h3>データ編集 <span id="edit-date" class="small muted"></span></h3>
      <label>睡眠時間 (h): <input type="number" step="0.1" id="edit-hours"></label><br>
      <label>PVT 平均 (ms): <input type="number" id="edit-pvt-avg"></label><br>
      <div style="margin-top:.6rem">
        <button id="save-edit">保存</button>
        <button id="delete-edit" class="warn">削除</button>
        <button id="close-edit">閉じる</button>
      </div>
    </div>
  </div>

  <!-- 詳細モーダル（カレンダーから開く） -->
  <div id="detail-modal">
    <div class="dialog">
      <button id="close-detail" style="float:right">閉じる</button>
      <h3 id="detail-date">—</h3>
      <div id="detail-body"></div>
    </div>
  </div>

</div>

<script>
/* =========================
   データ構造とロード
   ========================= */

const SKEY = "sleepHistory_v2";
const PKEY = "pvtHistory_v2";
const S_BACK = "sleepHistory_backup_v2";
const P_BACK = "pvtHistory_backup_v2";
const SLEEPINESS_KEY = "sleepinessHistory_v1";

let sleepHistory = [];
let pvtHistory = [];
let sleepinessHistory = []; // {date: 'YYYY-MM-DD', value: 1-5, createdAt: iso}

let aggSleepMap = {};
let aggPvtMap = {};

function getDateString(d) { return d.toISOString().split('T')[0]; }
function timeToHM(d){ return d.toTimeString().split(' ')[0].slice(0,5); }

/* safeLoad: load raw arrays, sanitize entries, then build aggregates */
function safeLoad() {
  try {
    sleepHistory = JSON.parse(localStorage.getItem(SKEY) || "[]");
    pvtHistory = JSON.parse(localStorage.getItem(PKEY) || "[]");
    sleepinessHistory = JSON.parse(localStorage.getItem(SLEEPINESS_KEY) || "[]");
  } catch (e) {
    console.warn("localStorage 読み込みエラー。バックアップを試みます。", e);
    const sb = localStorage.getItem(S_BACK);
    const pb = localStorage.getItem(P_BACK);
    if (sb || pb) {
      try {
        if (sb) sleepHistory = JSON.parse(sb);
        if (pb) pvtHistory = JSON.parse(pb);
        sleepinessHistory = [];
        alert("破損データをバックアップから復元しました。");
      } catch (ee) {
        console.error("バックアップも破損しています：", ee);
        sleepHistory = []; pvtHistory = []; sleepinessHistory = [];
      }
    } else {
      sleepHistory = []; pvtHistory = []; sleepinessHistory = [];
    }
  }
  validateAndCleanData();
}

/* validateAndCleanData:
   - sanitize raw arrays (filter out invalid entries)
   - keep duplicates in raw arrays (we DO NOT collapse raw entries)
   - build aggregated maps used for charts/calendar (average + count + details)
*/
function validateAndCleanData(){
  // sanitize sleepHistory: keep valid entries only
  sleepHistory = (sleepHistory || []).filter(r => {
    if (!r || !r.date) return false;
    if (r.hours == null && r.sleepDuration != null) r.hours = parseFloat(r.sleepDuration);
    if (typeof r.hours === 'string') r.hours = parseFloat(r.hours) || null;
    if (r.hours != null && (r.hours < 0 || r.hours > 48)) return false;
    return true;
  });

  // sanitize pvtHistory
  pvtHistory = (pvtHistory || []).filter(r => {
    if (!r || !r.date) return false;
    if (typeof r.avg === 'string') r.avg = parseFloat(r.avg) || null;
    if (r.avg != null && (r.avg < 0 || r.avg > 10000)) return false;
    return true;
  });

  // sanitize sleepinessHistory
  sleepinessHistory = (sleepinessHistory || []).filter(r => {
    if (!r || !r.date || typeof r.value !== 'number') return false;
    if (r.value < 1 || r.value > 5) return false;
    return true;
  });

  // rebuild aggregates
  aggSleepMap = {};
  for (let r of sleepHistory){
    const d = r.date;
    if (!aggSleepMap[d]) aggSleepMap[d] = { details: [], count:0, avgHours: null };
    if (r.hours != null) {
      aggSleepMap[d].details.push({ hours: r.hours, bedtime: r.bedtime||null, waketime: r.waketime||null, createdAt: r.createdAt||null });
      aggSleepMap[d].count++;
    } else {
      aggSleepMap[d].details.push({ hours: null, bedtime: r.bedtime||null, waketime: r.waketime||null, createdAt: r.createdAt||null });
      aggSleepMap[d].count++;
    }
  }
  Object.keys(aggSleepMap).forEach(d=>{
    const vals = aggSleepMap[d].details.map(x=>x.hours).filter(v=>v!=null);
    if (vals.length) {
      aggSleepMap[d].avgHours = vals.reduce((a,b)=>a+b,0)/vals.length;
    } else {
      aggSleepMap[d].avgHours = null;
    }
  });

  aggPvtMap = {};
  for (let r of pvtHistory){
    const d = r.date;
    if (!aggPvtMap[d]) aggPvtMap[d] = { details: [], count:0, avgAvg: null };
    aggPvtMap[d].details.push({ avg: r.avg!=null ? r.avg : null, lapses: r.lapses!=null ? r.lapses : null, reactions: r.reactions||[], createdAt: r.createdAt||null });
    aggPvtMap[d].count++;
  }
  Object.keys(aggPvtMap).forEach(d=>{
    const vals = aggPvtMap[d].details.map(x=>x.avg).filter(v=>v!=null);
    if (vals.length) aggPvtMap[d].avgAvg = vals.reduce((a,b)=>a+b,0)/vals.length;
    else aggPvtMap[d].avgAvg = null;
  });

  // persist sanitized raw arrays (keep raw duplicates)
  localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
  localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
  localStorage.setItem(SLEEPINESS_KEY, JSON.stringify(sleepinessHistory));
}

/* =========================
   保存ユーティリティ（バックアップ含む）
   ========================= */
function saveWithBackup(){
  try {
    localStorage.setItem(S_BACK, localStorage.getItem(SKEY) || "[]");
    localStorage.setItem(P_BACK, localStorage.getItem(PKEY) || "[]");
    localStorage.setItem(SKEY, JSON.stringify(sleepHistory));
    localStorage.setItem(PKEY, JSON.stringify(pvtHistory));
    localStorage.setItem(SLEEPINESS_KEY, JSON.stringify(sleepinessHistory));
    console.log("saved (and backed up).");
  } catch (e) {
    console.error("保存エラー:", e);
    alert("保存に失敗しました。ブラウザのストレージ容量や権限を確認してください。");
  }
}

/* =========================
   初期ロード
   ========================= */
safeLoad();

/* =========================
   Chart: 線グラフ（睡眠時間／PVT）と散布図（相関）
   - uses aggregates (avg per date)
   ========================= */
const timeCtx = document.getElementById('timeChart').getContext('2d');
let timeChart;

function buildTimeChart(){
  // collect dates from aggregated maps
  const datesSet = new Set([...Object.keys(aggSleepMap), ...Object.keys(aggPvtMap)]);
  const dates = Array.from(datesSet).sort((a,b)=> new Date(a) - new Date(b));

  const sleepData = dates.map(d => {
    const rec = aggSleepMap[d];
    return rec && rec.avgHours != null ? parseFloat(rec.avgHours.toFixed(1)) : null;
  });

  const pvtData = dates.map(d => {
    const rec = aggPvtMap[d];
    return rec && rec.avgAvg != null ? parseFloat(rec.avgAvg.toFixed(1)) : null;
  });

  // scatter pairs from dates where both exist and not null
  const pairs = [];
  dates.forEach(d=>{
    const s = aggSleepMap[d] && aggSleepMap[d].avgHours != null ? aggSleepMap[d].avgHours : null;
    const p = aggPvtMap[d] && aggPvtMap[d].avgAvg != null ? aggPvtMap[d].avgAvg : null;
    if (s != null && p != null) pairs.push({x: s, y: p});
  });

  if (!timeChart){
    timeChart = new Chart(timeCtx, {
      type: 'line',
      data: {
        labels: dates,
        datasets: [
          { type: 'line', label: '睡眠時間 (h)', data: sleepData, yAxisID:'y1', borderColor: '#2d7be8', spanGaps: true, tension:0.2 },
          { type: 'line', label: '反応時間 (ms)', data: pvtData, yAxisID:'y2', borderColor: '#e64c3c', spanGaps: true, tension:0.2 },
          { type: 'scatter', label: '散布（睡眠 vs PVT）', data: pairs, xAxisID: 'xSleep', yAxisID: 'yPvt', backgroundColor: '#8e44ad', pointRadius:4 }
        ]
      },
      options: {
        interaction: { mode: 'index', intersect: false },
        stacked: false,
        scales: {
          y1: { type: 'linear', position: 'left', min:0, max:12, title:{display:true,text:'睡眠時間 (h)'} },
          y2: { type: 'linear', position: 'right', min:0, max:1000, title:{display:true,text:'反応時間 (ms)'} },
          x: { display: false },
          xSleep: { display: false, type: 'linear', position: 'bottom' },
          yPvt: { display: false, type: 'linear', position: 'right' }
        },
        plugins: { legend: { display: true } }
      },
      plugins: [{
        id: 'regressionLine',
        afterDatasetsDraw(chart){
          const scatterDs = chart.data.datasets.find(ds => ds.type === 'scatter');
          if (!scatterDs || scatterDs.data.length < 2) return;
          const xs = scatterDs.data.map(p => p.x);
          const ys = scatterDs.data.map(p => p.y);
          try {
            const corr = ss.sampleCorrelation(xs, ys);
            const lr = ss.linearRegression(ss.zip(xs, ys));
            const line = ss.linearRegressionLine(lr);
            const xScale = chart.scales.xSleep;
            const yScale = chart.scales.yPvt;
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const xPx1 = xScale.getPixelForValue(minX);
            const xPx2 = xScale.getPixelForValue(maxX);
            const yVal1 = line(minX);
            const yVal2 = line(maxX);
            const yPx1 = yScale.getPixelForValue(yVal1);
            const yPx2 = yScale.getPixelForValue(yVal2);
            const ctx = chart.ctx;
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(46,204,113,0.9)';
            ctx.moveTo(xPx1, yPx1);
            ctx.lineTo(xPx2, yPx2);
            ctx.stroke();
            ctx.restore();
            document.getElementById('corr-area').textContent =
              `相関 (Pearson): ${corr===null? '計算不可' : corr.toFixed(3)}　回帰: y = ${lr.m.toFixed(2)}x + ${lr.b.toFixed(1)} （x=睡眠時間, y=反応時間 ms）`;
          } catch (e) {
            console.error("回帰線描画エラー:", e);
          }
        }
      }]
    });
  } else {
    timeChart.data.labels = dates;
    timeChart.data.datasets[0].data = sleepData;
    timeChart.data.datasets[1].data = pvtData;
    timeChart.data.datasets[2].data = pairs;
    timeChart.update();
  }
}

/* =========================
   記録処理（重複チェック、上書き確認、手動入力）
   - raw arrays keep all entries; duplicates allowed
   ========================= */

let tempSleepTime = null;
// 眠気評価モーダル表示
function showSleepinessModal(){
  const modal = document.getElementById('sleepiness-modal');
  const options = document.getElementById('sleepiness-options');
  options.innerHTML = '';
  for(let i=1;i<=5;i++){
    const label = document.createElement('label');
    label.style.margin = '0 8px';
    label.innerHTML = `<input type="radio" name="sleepiness" value="${i}"> ${i}`;
    options.appendChild(label);
  }
  document.getElementById('sleepiness-feedback').textContent = '';
  modal.style.display = 'flex';
}

let sleepinessValue = null;

document.getElementById('btn-sleep').addEventListener('click', ()=>{
  showSleepinessModal();
});

document.getElementById('sleepiness-cancel').addEventListener('click', ()=>{
  document.getElementById('sleepiness-modal').style.display = 'none';
});

document.getElementById('sleepiness-save').addEventListener('click', ()=>{
  const radios = document.getElementsByName('sleepiness');
  let val = null;
  for(const r of radios){ if(r.checked) val = parseInt(r.value); }
  if(!val){
    document.getElementById('sleepiness-feedback').textContent = '評価を選択してください';
    return;
  }
  sleepinessValue = val;
  document.getElementById('sleepiness-modal').style.display = 'none';
  // 保存処理
  const today = getDateString(new Date());
  // 既存データ上書き（同日）
  const idx = sleepinessHistory.findIndex(r=>r.date===today);
  if(idx>=0){
    sleepinessHistory[idx].value = sleepinessValue;
    sleepinessHistory[idx].createdAt = new Date().toISOString();
  }else{
    sleepinessHistory.push({date: today, value: sleepinessValue, createdAt: new Date().toISOString()});
  }
  saveWithBackup();
  tempSleepTime = new Date();
  document.getElementById('sleep-feedback').textContent = '眠気評価 ' + sleepinessValue + ' を記録しました（' + timeToHM(tempSleepTime) + '）';
});

document.getElementById('btn-wake').addEventListener('click', ()=>{
  if (!tempSleepTime){
    if (!confirm('直前に「おやすみ」が記録されていません。手動入力しますか？（OK=手動入力, キャンセル=現在時刻で記録）')) {
      const now = new Date();
      const today = getDateString(now);
      const assumedHours = 7.0;
      if (confirm(`就寝時刻がありません。\n現在時刻で起床を記録しますか？\n（就寝時刻が不明なため仮に ${assumedHours} 時間の睡眠として保存します。保存しますか？）`)){
        // add raw entry (allow duplicates)
        sleepHistory.push({date: today, hours: assumedHours, createdAt: new Date().toISOString()});
        saveWithBackup(); validateAndCleanData(); buildTimeChart();
        document.getElementById('sleep-feedback').textContent='仮の睡眠時間を保存しました';
        return;
      } else {
        showManualArea();
        return;
      }
    } else {
      showManualArea();
      return;
    }
  } else {
    const wake = new Date();
    const diffH = (wake - tempSleepTime) / 1000 / 3600;
    const recDate = getDateString(wake); // record by wake date
    // push raw entry (duplicates allowed)
    sleepHistory.push({date: recDate, hours: parseFloat(diffH.toFixed(1)), bedtime: timeToHM(tempSleepTime), waketime: timeToHM(wake), createdAt: new Date().toISOString()});
    tempSleepTime = null;
    saveWithBackup(); validateAndCleanData(); buildTimeChart();
    document.getElementById('sleep-feedback').textContent = `睡眠時間 ${diffH.toFixed(1)} 時間として保存しました。`;
  }
});

// 手動入力エリア
function showManualArea(){
  document.getElementById('manual-area').style.display = 'block';
  const today = new Date();
  document.getElementById('manual-date').value = getDateString(today);
}
document.getElementById('btn-manual').addEventListener('click', showManualArea);
document.getElementById('btn-manual-cancel').addEventListener('click', ()=> document.getElementById('manual-area').style.display='none');

document.getElementById('btn-manual-save').addEventListener('click', ()=>{
  const date = document.getElementById('manual-date').value;
  const st = document.getElementById('manual-sleep-time').value;
  const wt = document.getElementById('manual-wake-time').value;
  if (!date) { alert('日付を指定してください'); return; }
  let hours = null;
  if (st && wt){
    const sd = new Date(date + 'T' + st);
    let wd = new Date(date + 'T' + wt);
    if (wd <= sd) wd.setDate(wd.getDate()+1);
    hours = (wd - sd)/1000/3600;
    hours = parseFloat(hours.toFixed(1));
  } else if (st || wt){
    hours = null;
  } else {
    alert('就寝または起床時刻のいずれかを入力してください。');
    return;
  }
  // append as new raw entry (do not force overwrite)
  sleepHistory.push({date, hours, bedtime: st||null, waketime: wt||null, createdAt: new Date().toISOString()});
  saveWithBackup(); validateAndCleanData(); buildTimeChart(); document.getElementById('manual-area').style.display='none';
  document.getElementById('sleep-feedback').textContent = '手動入力を保存しました';
});

/* =========================
   PVT 実装（既存ロジックを改良）
   - raw entries appended; duplicates allowed
   ========================= */
const pvtArea = document.getElementById('pvt-area');
const pvtFeedback = document.getElementById('pvt-feedback');
const btnStartPvt = document.getElementById('btn-start-pvt');
const btnCancelPvt = document.getElementById('btn-cancel-pvt');

let pvtRunning = false;
let pvtCancelHandler = null;

btnStartPvt.addEventListener('click', ()=> startPVT(15));
btnCancelPvt.addEventListener('click', ()=> {
  if (pvtRunning) {
    pvtRunning = false;
    pvtArea.textContent = '中止';
    pvtFeedback.textContent = 'テストが中止されました';
    btnCancelPvt.disabled = true;
    // クリックイベント解除
    pvtArea.onclick = null;
    if (pvtCancelHandler) {
      pvtArea.removeEventListener('click', pvtCancelHandler);
      pvtCancelHandler = null;
    }
  }
});

function startPVT(totalTrials=15){
  pvtFeedback.textContent='';
  let trial = 0;
  let times = [];
  pvtArea.textContent = '準備中...';
  pvtRunning = true;
  btnCancelPvt.disabled = false;

  function runTrial(){
    if (!pvtRunning) return;
    if (trial >= totalTrials){
      const avg = times.reduce((a,b)=>a+b,0)/times.length;
      const lapses = times.filter(t=>t>500).length;
      const today = getDateString(new Date());
      // append as new raw PVT entry (do not force overwrite)
      pvtHistory.push({date: today, avg: parseFloat(avg.toFixed(1)), lapses, reactions: times, createdAt: new Date().toISOString()});
      saveWithBackup(); validateAndCleanData(); buildTimeChart();
      pvtArea.textContent = '完了';
      pvtFeedback.textContent = `平均: ${avg.toFixed(1)}ms, ラプス: ${lapses}回`;
      btnCancelPvt.disabled = true;
      pvtArea.onclick = null;
      return;
    }
    pvtArea.textContent = '待機中...';
    pvtArea.onclick = null;
    const delay = Math.random()*3000 + 1500;
    setTimeout(()=>{
      if (!pvtRunning) return;
      pvtArea.textContent = 'クリック！';
      pvtCancelHandler = function handler(){
        const rt = performance.now() - start;
        times.push(rt);
        trial++;
        pvtFeedback.textContent = `試行 ${trial} = ${rt.toFixed(0)} ms`;
        pvtArea.removeEventListener('click', handler);
        pvtArea.onclick = null;
        runTrial();
      };
      const start = performance.now();
      pvtArea.addEventListener('click', pvtCancelHandler);
    }, delay);
  }
  runTrial();
}

/* =========================
   カレンダー描画＋編集（カレンダーは平均表示、(*) は複数件）
   - クリックで「詳細モーダル」を開く（その日の全データ一覧）
   ========================= */
function toggleCalendar(){
  const cal = document.getElementById('calendar');
  cal.style.display = cal.style.display === 'table' ? 'none' : 'table';
  if (cal.style.display === 'table') renderCalendar();
}
document.getElementById('toggle-calendar').addEventListener('click', toggleCalendar);

function renderCalendar(){
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const firstDay = new Date(year, month, 1).getDay();
  const lastDate = new Date(year, month+1, 0).getDate();
  let html = '<tr><th>日</th><th>月</th><th>火</th><th>水</th><th>木</th><th>金</th><th>土</th></tr><tr>';
  for (let i=0;i<firstDay;i++) html += '<td></td>';
  for (let d=1; d<=lastDate; d++){
    const mm = String(month+1).padStart(2,'0');
    const dd = String(d).padStart(2,'0');
    const dateStr = `${year}-${mm}-${dd}`;
    const sAgg = aggSleepMap[dateStr];
    const pAgg = aggPvtMap[dateStr];
    let sleepHtml = '';
    let pvtHtml = '';
    if (sAgg){
      const avg = sAgg.avgHours != null ? sAgg.avgHours.toFixed(1) + 'h' : '';
      const star = sAgg.count > 1 ? ' <span class="note-star">(*)</span>' : '';
      sleepHtml = `<div class="small"> ${avg}${star}</div>`;
    }
    if (pAgg){
      const avg = pAgg.avgAvg != null ? Math.round(pAgg.avgAvg) + 'ms' : '';
      const star = pAgg.count > 1 ? ' <span class="note-star">(*)</span>' : '';
      pvtHtml = `<div class="small"> ${avg}${star}</div>`;
    }
    html += `<td data-date="${dateStr}"><strong>${d}</strong>${sleepHtml}${pvtHtml}</td>`;
    if ((d+firstDay)%7===0) html += '</tr><tr>';
  }
  html += '</tr>';
  document.getElementById('calendar').innerHTML = html;
  document.querySelectorAll('#calendar td[data-date]').forEach(td=>{
    td.onclick = ()=> {
      const date = td.dataset.date;
      openDetailModal(date); // open details modal (not edit)
    };
  });
}

/* 編集モーダル（既存） */
let editDate = null;
function openEditModal(date){
  editDate = date;
  document.getElementById('edit-date').textContent = date;
  // For edit modal, we keep original behavior: show first matching record (if multiple exists)
  const s = sleepHistory.find(r=>r.date===date);
  const p = pvtHistory.find(r=>r.date===date);
  document.getElementById('edit-hours').value = s ? (s.hours != null ? s.hours : '') : '';
  document.getElementById('edit-pvt-avg').value = p ? (p.avg != null ? p.avg : '') : '';
  document.getElementById('edit-modal').style.display = 'flex';
}
document.getElementById('close-edit').addEventListener('click', ()=> document.getElementById('edit-modal').style.display='none');

document.getElementById('save-edit').addEventListener('click', ()=>{
  if (!editDate) return;
  const h = parseFloat(document.getElementById('edit-hours').value);
  const a = parseFloat(document.getElementById('edit-pvt-avg').value);
  // sleep: edit first matching raw entry for that date (preserves duplicate entries)
  const sIdx = sleepHistory.findIndex(r=>r.date===editDate);
  if (!isNaN(h)){
    if (sIdx>=0) sleepHistory[sIdx].hours = h;
    else sleepHistory.push({date: editDate, hours: h, createdAt: new Date().toISOString()});
  }
  // pvt
  const pIdx = pvtHistory.findIndex(r=>r.date===editDate);
  if (!isNaN(a)){
    if (pIdx>=0) pvtHistory[pIdx].avg = a;
    else pvtHistory.push({date: editDate, avg: a, lapses: 0, reactions: [], createdAt: new Date().toISOString()});
  }
  saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
  document.getElementById('edit-modal').style.display = 'none';
});
document.getElementById('delete-edit').addEventListener('click', ()=>{
  if (!editDate) return;
  if (!confirm(editDate + ' のデータを削除しますか？')) return;
  // delete ALL raw entries for that date to be safe (this matches former UX expectation)
  sleepHistory = sleepHistory.filter(r=>r.date!==editDate);
  pvtHistory = pvtHistory.filter(r=>r.date!==editDate);
  saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
  document.getElementById('edit-modal').style.display = 'none';
});

/* =========================
   エクスポート / インポート
   - インポート時: OK=上書き, Cancel=追加保存（重複を残す） を実現
   ========================= */
document.getElementById('btn-export').addEventListener('click', ()=>{
  const data = {sleepHistory, pvtHistory, exportedAt: new Date().toISOString()};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'sleep_pvt_data.json'; a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('btn-import').addEventListener('click', ()=>{
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,application/json';
  input.onchange = (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      try {
        const obj = JSON.parse(ev.target.result);
        // confirm: 上書き? (OK=上書き, Cancel=追加保存)
        if (confirm('インポートしたデータで上書きしますか？（キャンセルで追加保存／重複が残ります）')){
          sleepHistory = obj.sleepHistory || [];
          pvtHistory = obj.pvtHistory || [];
        } else {
          // 追加（両方残す）
          sleepHistory = (sleepHistory || []).concat(obj.sleepHistory || []);
          pvtHistory = (pvtHistory || []).concat(obj.pvtHistory || []);
        }
        saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
        alert('インポート完了');
      } catch (err) {
        alert('ファイルの読み込みに失敗しました:' + err);
      }
    };
    reader.readAsText(f);
  };
  input.click();
});

/* =========================
   全データ削除 / バックアップ復元
   ========================= */
document.getElementById('btn-clear').addEventListener('click', ()=>{
  if (!confirm('本当に全データを削除しますか？')) return;
  sleepHistory = []; pvtHistory = [];
  saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
  alert('すべてのデータを削除しました');
});
document.getElementById('btn-restore-backup').addEventListener('click', ()=>{
  if (!confirm('最後のバックアップから復元しますか？現在のデータは上書きされます。')) return;
  try {
    const sb = JSON.parse(localStorage.getItem(S_BACK) || "[]");
    const pb = JSON.parse(localStorage.getItem(P_BACK) || "[]");
    sleepHistory = sb; pvtHistory = pb;
    saveWithBackup(); validateAndCleanData(); buildTimeChart(); renderCalendar();
    alert('バックアップから復元しました');
  } catch (e) { alert('復元に失敗しました: ' + e); }
});

// ...existing code...

/* =========================
   カレンダー詳細モーダル（クリックで全データ一覧を表示）
   ========================= */
function openDetailModal(dateStr){
  const modal = document.getElementById('detail-modal');
  document.getElementById('detail-date').textContent = dateStr + ' の詳細';
  const body = document.getElementById('detail-body');
  body.innerHTML = '';


  // 眠気データ
  const sleepiness = sleepinessHistory.find(r=>r.date===dateStr);
  if(sleepiness){
    const div = document.createElement('div');
    div.className = 'small';
    div.style.marginBottom = '8px';
    div.textContent = `眠気評価: ${sleepiness.value}（1:全く眠くない～5:非常に眠い）`;
    body.appendChild(div);
  }

  // sleep details
  const sAgg = aggSleepMap[dateStr];
  if (sAgg){
    const header = document.createElement('h4');
    header.textContent = `睡眠（${sAgg.count} 件）`;
    body.appendChild(header);
    sAgg.details.forEach((it, i)=>{
      const div = document.createElement('div');
      div.textContent = `${i+1}: ${it.hours!=null ? it.hours + ' h' : '(時間未記入)'} ` + (it.bedtime ? `(就寝 ${it.bedtime})` : '') + (it.waketime ? `(起床 ${it.waketime})` : '') + (it.createdAt ? ` — ${new Date(it.createdAt).toLocaleString()}` : '');
      body.appendChild(div);
    });
    const avgDiv = document.createElement('div');
    avgDiv.style.marginTop = '6px';
    avgDiv.textContent = '平均: ' + (sAgg.avgHours != null ? sAgg.avgHours.toFixed(1) + ' h' : '—');
    body.appendChild(avgDiv);
  } else {
    const no = document.createElement('div'); no.textContent = '睡眠データはありません';
    body.appendChild(no);
  }

  // pvt details
  const pAgg = aggPvtMap[dateStr];
  if (pAgg){
    const header = document.createElement('h4');
    header.textContent = `PVT（${pAgg.count} 件）`;
    body.appendChild(header);
    pAgg.details.forEach((it, i)=>{
      const div = document.createElement('div');
      div.textContent = `${i+1}: ${it.avg!=null ? it.avg + ' ms' : '(平均未記入)'} / ラプス ${it.lapses!=null ? it.lapses : '-'} ` + (it.createdAt ? `— ${new Date(it.createdAt).toLocaleString()}` : '');
      body.appendChild(div);
      if (it.reactions && it.reactions.length){
        const small = document.createElement('div');
        small.style.fontSize='0.85em';
        small.style.color='#666';
        small.textContent = `  試行数: ${it.reactions.length}（反応時間の配列を保存）`;
        body.appendChild(small);
      }
    });
    const avgDiv = document.createElement('div');
    avgDiv.style.marginTop = '6px';
    avgDiv.textContent = '平均反応時間: ' + (pAgg.avgAvg != null ? Math.round(pAgg.avgAvg) + ' ms' : '—');
    body.appendChild(avgDiv);
  } else {
    const no = document.createElement('div'); no.textContent = 'PVTデータはありません';
    body.appendChild(no);
  }

  modal.style.display = 'flex';
}
document.getElementById('close-detail').addEventListener('click', ()=> document.getElementById('detail-modal').style.display='none');
window.addEventListener('click', (e)=> { if (e.target.id === 'detail-modal') document.getElementById('detail-modal').style.display='none'; });

/* =========================
   起動時処理
   ========================= */
buildTimeChart();
renderCalendar();
// ...existing code...

/* =========================
   初回アドバイス
   ========================= */
console.log("注意: localStorage は XSS による盗難のリスクがあるため、機密情報は保存しないでください。大規模データや同期が必要なら IndexedDB / サーバー同期を検討してください。");

</script>
</body>
</html>


